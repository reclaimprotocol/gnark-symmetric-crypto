package chachaV3

import (
	"crypto/rand"
	"testing"

	"gnark-symmetric-crypto/utils"

	"github.com/consensys/gnark-crypto/ecc"
	"github.com/consensys/gnark/frontend"
	"github.com/consensys/gnark/test"
	"golang.org/x/crypto/chacha20"
)

type qrBlock struct {
	In  [16][BITS_PER_WORD]frontend.Variable
	Out [16][BITS_PER_WORD]frontend.Variable `gnark:",public"`
}

func (c *qrBlock) Define(api frontend.API) error {

	a0 := api.ToBinary(0x11111111)
	a1 := api.ToBinary(0x01020304)
	a2 := api.ToBinary(0x9b8d6f43)
	a3 := api.ToBinary(0x01234567)

	b0 := api.ToBinary(0xea2a92f4)
	b1 := api.ToBinary(0xcb1cf8ce)
	b2 := api.ToBinary(0x4581472e)
	b3 := api.ToBinary(0x5881c4bb)

	for i := 0; i < BITS_PER_WORD; i++ {
		c.In[0][i] = a0[i]
		c.In[1][i] = a1[i]
		c.In[2][i] = a2[i]
		c.In[3][i] = a3[i]

		c.Out[0][i] = b0[i]
		c.Out[1][i] = b1[i]
		c.Out[2][i] = b2[i]
		c.Out[3][i] = b3[i]
	}

	QR(api, &c.In, 0, 1, 2, 3)
	for i := range c.Out {
		a := api.FromBinary(c.In[i][:]...)
		b := api.FromBinary(c.Out[i][:]...)
		api.AssertIsEqual(a, b)

	}
	return nil
}

func TestQR(t *testing.T) {
	assert := test.NewAssert(t)
	witness := qrBlock{}
	for i := 0; i < 16; i++ {
		witness.In[i] = [BITS_PER_WORD]frontend.Variable{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
		witness.Out[i] = [BITS_PER_WORD]frontend.Variable{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
	}

	err := test.IsSolved(&qrBlock{}, &witness, ecc.BN254.ScalarField())
	assert.NoError(err)

	assert.CheckCircuit(&qrBlock{}, test.WithValidAssignment(&witness))

}

type roundCircuit struct {
	In  [16][BITS_PER_WORD]frontend.Variable
	Out [16][BITS_PER_WORD]frontend.Variable `gnark:",public"`
}

func (c *roundCircuit) Define(api frontend.API) error {

	var workingState [16][BITS_PER_WORD]frontend.Variable
	copy(workingState[:], c.In[:])

	Round(api, &workingState)
	Serialize(&workingState)

	for i := range c.Out {

		a := api.FromBinary(c.Out[i][:]...)
		b := api.FromBinary(workingState[i][:]...)
		api.AssertIsEqual(a, b)
	}

	return nil
}

func TestRound(t *testing.T) {
	assert := test.NewAssert(t)

	in := []frontend.Variable{
		0x61707865, 0x3320646e, 0x79622d32, 0x6b206574,
		0x03020100, 0x07060504, 0x0b0a0908, 0x0f0e0d0c,
		0x13121110, 0x17161514, 0x1b1a1918, 0x1f1e1d1c,
		0x00000001, 0x09000000, 0x4a000000, 0x00000000}

	out := utils.BytesToUint32BERaw([]uint8{
		0x10, 0xf1, 0xe7, 0xe4, 0xd1, 0x3b, 0x59, 0x15, 0x50, 0x0f, 0xdd, 0x1f, 0xa3, 0x20, 0x71, 0xc4,
		0xc7, 0xd1, 0xf4, 0xc7, 0x33, 0xc0, 0x68, 0x03, 0x04, 0x22, 0xaa, 0x9a, 0xc3, 0xd4, 0x6c, 0x4e,
		0xd2, 0x82, 0x64, 0x46, 0x07, 0x9f, 0xaa, 0x09, 0x14, 0xc2, 0xd7, 0x05, 0xd9, 0x8b, 0x02, 0xa2,
		0xb5, 0x12, 0x9c, 0xd1, 0xde, 0x16, 0x4e, 0xb9, 0xcb, 0xd0, 0x83, 0xe8, 0xa2, 0x50, 0x3c, 0x4e})

	witness := roundCircuit{}

	for i := 0; i < len(in); i++ {
		a := utils.Uint32ToBits(in[i])
		b := utils.Uint32ToBits(out[i])
		copy(witness.In[i][:], a[:])
		copy(witness.Out[i][:], b[:])
	}
	err := test.IsSolved(&roundCircuit{}, &witness, ecc.BN254.ScalarField())
	assert.NoError(err)

	assert.CheckCircuit(&roundCircuit{}, test.WithValidAssignment(&witness))
}

func TestCipher(t *testing.T) {
	assert := test.NewAssert(t)

	bKey := []uint8{
		0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
		0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f}

	bNonce := []uint8{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4a, 0x00, 0x00, 0x00, 0x00}

	counter := 1

	/*bPt := []uint8{
		0x4c, 0x61, 0x64, 0x69, 0x65, 0x73, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x47, 0x65, 0x6e, 0x74, 0x6c,
		0x65, 0x6d, 0x65, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c, 0x61, 0x73,
		0x73, 0x20, 0x6f, 0x66, 0x20, 0x27, 0x39, 0x39, 0x3a, 0x20, 0x49, 0x66, 0x20, 0x49, 0x20, 0x63,
		0x6f, 0x75, 0x6c, 0x64, 0x20, 0x6f, 0x66, 0x66, 0x65, 0x72, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x6f,
		0x6e, 0x6c, 0x79, 0x20, 0x6f, 0x6e, 0x65, 0x20, 0x74, 0x69, 0x70, 0x20, 0x66, 0x6f, 0x72, 0x20,
		0x74, 0x68, 0x65, 0x20, 0x66, 0x75, 0x74, 0x75, 0x72, 0x65, 0x2c, 0x20, 0x73, 0x75, 0x6e, 0x73,
		0x63, 0x72, 0x65, 0x65, 0x6e, 0x20, 0x77, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x62, 0x65, 0x20, 0x69,
		0x4c, 0x61, 0x64, 0x69, 0x65, 0x73, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x47, 0x65, 0x6e, 0x74, 0x6c,
	}

	bCt := []uint8{
		0x6e, 0x2e, 0x35, 0x9a, 0x25, 0x68, 0xf9, 0x80, 0x41, 0xba, 0x07, 0x28, 0xdd, 0x0d, 0x69, 0x81,
		0xe9, 0x7e, 0x7a, 0xec, 0x1d, 0x43, 0x60, 0xc2, 0x0a, 0x27, 0xaf, 0xcc, 0xfd, 0x9f, 0xae, 0x0b,
		0xf9, 0x1b, 0x65, 0xc5, 0x52, 0x47, 0x33, 0xab, 0x8f, 0x59, 0x3d, 0xab, 0xcd, 0x62, 0xb3, 0x57,
		0x16, 0x39, 0xd6, 0x24, 0xe6, 0x51, 0x52, 0xab, 0x8f, 0x53, 0x0c, 0x35, 0x9f, 0x08, 0x61, 0xd8,
		0x07, 0xca, 0x0d, 0xbf, 0x50, 0x0d, 0x6a, 0x61, 0x56, 0xa3, 0x8e, 0x08, 0x8a, 0x22, 0xb6, 0x5e,
		0x52, 0xbc, 0x51, 0x4d, 0x16, 0xcc, 0xf8, 0x06, 0x81, 0x8c, 0xe9, 0x1a, 0xb7, 0x79, 0x37, 0x36,
		0x5a, 0xf9, 0x0b, 0xbf, 0x74, 0xa3, 0x5b, 0xe6, 0xb4, 0x0b, 0x8e, 0xed, 0xf2, 0x78, 0x5e, 0x42,
		0xbf, 0x02, 0x10, 0x6a, 0x16, 0x53, 0x3a, 0xc0, 0xe6, 0x9f, 0x9c, 0xaf, 0x5c, 0xff, 0xb0, 0x81,
	}*/

	bPt := make([]byte, Blocks*64)
	rand.Read(bPt)
	bCt := make([]byte, Blocks*64)

	cipher, err := chacha20.NewUnauthenticatedCipher(bKey, bNonce)
	assert.NoError(err)

	cipher.SetCounter(1)
	cipher.XORKeyStream(bCt, bPt)

	witness := ChaChaCircuit{}

	copy(witness.Key[:], utils.BytesToUint32LEBits(bKey))
	copy(witness.Nonce[:], utils.BytesToUint32LEBits(bNonce))
	witness.Counter = utils.Uint32ToBits(counter)
	copy(witness.In[:], utils.BytesToUint32BEBits(bPt))
	copy(witness.Out[:], utils.BytesToUint32BEBits(bCt))

	err = test.IsSolved(&ChaChaCircuit{}, &witness, ecc.BN254.ScalarField())
	assert.NoError(err)

	assert.CheckCircuit(&ChaChaCircuit{}, test.WithValidAssignment(&witness))
}
